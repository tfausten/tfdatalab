rm(i, y, ctry, years_iot, sub, countrygroup)
##graph of country dispersion
library(ggplot2)
library(directlabels)
library(Cairo)
##inventor graphs
graph_inv_disp <- ggplot(data = disp_data_iot[disp_data_iot$year < 2015 & disp_data_iot$year > 1993, ], aes(year, inv_disp, color = country))+
stat_smooth(size = 1, se = FALSE, span = 0.3) +
#geom_line(size = 1) +
ylab("country dispersion") +
labs(title = "Country dispersion in selected countries (inventor data, IoT-categories)",
caption = "CH - Switzerland, CN - China, DE - Germany, FR - France, GB - Great Britain, JP - Japan, KR - Korea, US - United States") +
theme(plot.caption = element_text(size = 7.5))
direct.label(graph_inv_disp, last.polygons)
#number of patents
graph_inv_count <- ggplot(data = disp_data_iot[disp_data_iot$year < 2014 & disp_data_iot$year > 1993, ], aes(year, inv_count, color = country))+
#stat_smooth(size = 1, se = FALSE, span = 0.3) +
geom_line(size = 1) +
ylab("Patent count") +
labs(title = "Patent counts in selected countries (inventor data, IoT-categories)",
caption = "CH - Switzerland, CN - China, DE - Germany, FR - France, GB - Great Britain, JP - Japan, KR - Korea, US - United States") +
theme(plot.caption = element_text(size = 7.5))
direct.label(graph_inv_count, last.polygons)
##applicant graphs
graph_app_disp <- ggplot(data = disp_data_iot[disp_data_iot$year < 2013 & disp_data_iot$year > 1994, ], aes(year, app_disp, color = country))+
stat_smooth(size = 1, se = FALSE, span = 0.3) +
#geom_line(size = 1) +
ylab("country dispersion") +
labs(title = "Country dispersion in selected countries (applicant data, IoT-categories)",
caption = "CH - Switzerland, CN - China, DE - Germany, FR - France, GB - Great Britain, JP - Japan, KR - Korea, US - United States") +
theme(plot.caption = element_text(size = 7.5))
direct.label(graph_app_disp, last.polygons)
#number of patents
graph_app_count <- ggplot(data = disp_data_iot[disp_data_iot$year < 2015 & disp_data_iot$year > 1993, ], aes(year, app_count, color = country))+
#stat_smooth(size = 1, se = FALSE, span = 0.3) +
geom_line(size = 1) +
ylab("Patent count") +
labs(title = "Patent counts in selected countries (applicant data)",
caption = "CH - Switzerland, CN - China, DE - Germany, FR - France, GB - Great Britain, JP - Japan, KR - Korea, US - United States") +
theme(plot.caption = element_text(size = 7.5))
direct.label(graph_app_count, last.polygons)
rm(list = ls())
##
load("./data/TPF/201803_TPF_IPC.RData")
head(tpf_ipc, 30)
# IoT IPC-codes according to Ardito et al. 2017 and European Communities Trade Mark Association (2016)
#G05B019/418, G06F015/16, G08C017/02, H04B007/26, H04L012/28, H04L029/06, H04L029/08, H04W004/00, H04W072/04, H04W084/18
#IPC selector function. to return the Family_ids corresponding to a list of IPC-codes. One occurrence of an IPC-code is enough to be included in the
#output vector of Family_ids
ipc.select <- function (data, ipc) {
ids <- vector(mode = "numeric")
for (i in ipc) {
if (substr(i , 9, 10) == "00") i <- substr(i, 1, 8)     #remove last two figures if they are "00", to allow for inclusion of whole subclasses
ids <- c(ids, data[grep(i, data$IPC, fixed = TRUE), "Family_id"])
}
return(unique(ids))
}
#test function
ipc.select(tpf_ipc, ipc = c("C09B005/00", "C09B067/22"))
#make vector that holds IoT-relevant ids (according to Ardito et al. 2017)
iot_ids <- ipc.select(tpf_ipc, ipc = c("G05B019/418", "G06F015/16", "G08C017/02", "H04B007/26", "H04L012/28", "H04L029/06",
"H04L029/08", "H04W004/00", "H04W072/04", "H04W084/18"))
rm(tpf_ipc)     #ipc data not needed anymore
#load data for dispersion analysis
load("./data/TPF/dispersion.RData")        #for previously calculated family-specific dispersion data
head(dispersion)
load("./data/TPF/tpf_families.RData")      #for year data
load("./data/TPF/allcountries_app.RData")  #for country data on inventors
load("./data/TPF/allcountries_inv.RData")  #for country data on applicants
#data.frame for yearly country dispersion data (IoT-specific)
countrygroup <- c("JP", "US", "DE", "CN", "FR", "GB", "KR")     #modify this list to include different countries
disp_data_iot <- data.frame(year = rep(1975:2016, length.out = 42 * length(countrygroup)),
country = rep(countrygroup, each = 42), inv_disp = NA, app_disp = NA,
inv_count = NA, app_count = NA, stringsAsFactors = FALSE)
#for loop to fill the data.frame. Create workingvec of type character to avoid repeated conversion to character vector in the loop through the
#grep function used in the loop below
allcountries_inv <- as.character(allcountries_inv)
allcountries_app <- as.character(allcountries_app)
for (i in 1975:2016) {      #years to be included in the data.frame
years_iot <- intersect(which(tpf_families$first_app_year == i), iot_ids)  #the selection vector takes care of year and IPC selection
for (y in countrygroup) {
#inventor dispersioin
ctry <- grep(y, allcountries_inv, fixed = TRUE)       #ctry contains family_ids that have an inventor from country y
sub <- dispersion$D_inv[intersect(ctry, years_iot)]   #sub is a subset of dispersion data, containing only data relevant to years_iot and ctry
disp_data_iot$inv_disp[(i-1974) + 42 * (which(countrygroup == y) - 1)] <- mean(sub) #assign yearly country-speficic mean to data.frame. formula finds the correct position
disp_data_iot$inv_count[(i-1974) + 42 * (which(countrygroup == y) - 1)] <- length(sub) #assign patent count in similar fashion
#applicant dispersion
ctry <- grep(y, allcountries_app, fixed = TRUE)
sub <- dispersion$D_app[intersect(ctry, years_iot)]
disp_data_iot$app_disp[(i-1974) + 42 * (which(countrygroup == y) - 1)] <- mean(sub)
disp_data_iot$app_count[(i-1974) + 42 * (which(countrygroup == y) - 1)] <- length(sub)
print(c(i, y))
}
}
#cleanup
rm(i, y, ctry, years_iot, sub, countrygroup)
##graph of country dispersion
library(ggplot2)
library(directlabels)
library(Cairo)
##inventor graphs
graph_inv_disp <- ggplot(data = disp_data_iot[disp_data_iot$year < 2015 & disp_data_iot$year > 1993, ], aes(year, inv_disp, color = country))+
stat_smooth(size = 1, se = FALSE, span = 0.3) +
#geom_line(size = 1) +
ylab("country dispersion") +
labs(title = "Country dispersion in selected countries (inventor data, IoT-categories)",
caption = "CH - Switzerland, CN - China, DE - Germany, FR - France, GB - Great Britain, JP - Japan, KR - Korea, US - United States") +
theme(plot.caption = element_text(size = 7.5))
direct.label(graph_inv_disp, last.polygons)
#number of patents
graph_inv_count <- ggplot(data = disp_data_iot[disp_data_iot$year < 2014 & disp_data_iot$year > 1993, ], aes(year, inv_count, color = country))+
#stat_smooth(size = 1, se = FALSE, span = 0.3) +
geom_line(size = 1) +
ylab("Patent count") +
labs(title = "Patent counts in selected countries (inventor data, IoT-categories)",
caption = "CH - Switzerland, CN - China, DE - Germany, FR - France, GB - Great Britain, JP - Japan, KR - Korea, US - United States") +
theme(plot.caption = element_text(size = 7.5))
direct.label(graph_inv_count, last.polygons)
##applicant graphs
graph_app_disp <- ggplot(data = disp_data_iot[disp_data_iot$year < 2013 & disp_data_iot$year > 1994, ], aes(year, app_disp, color = country))+
stat_smooth(size = 1, se = FALSE, span = 0.3) +
#geom_line(size = 1) +
ylab("country dispersion") +
labs(title = "Country dispersion in selected countries (applicant data, IoT-categories)",
caption = "CH - Switzerland, CN - China, DE - Germany, FR - France, GB - Great Britain, JP - Japan, KR - Korea, US - United States") +
theme(plot.caption = element_text(size = 7.5))
direct.label(graph_app_disp, last.polygons)
#number of patents
graph_app_count <- ggplot(data = disp_data_iot[disp_data_iot$year < 2015 & disp_data_iot$year > 1993, ], aes(year, app_count, color = country))+
#stat_smooth(size = 1, se = FALSE, span = 0.3) +
geom_line(size = 1) +
ylab("Patent count") +
labs(title = "Patent counts in selected countries (applicant data)",
caption = "CH - Switzerland, CN - China, DE - Germany, FR - France, GB - Great Britain, JP - Japan, KR - Korea, US - United States") +
theme(plot.caption = element_text(size = 7.5))
direct.label(graph_app_count, last.polygons)
rm(list = ls())
blogdown:::serve_site()
getwd()
#knitr::opts_chunk$set(out.width='800px', dpi=200, fig.align = "left")
#create basic graphs of tpf applications per year and country
load("./data/TPF/tpf_families.RData")
#knitr::opts_chunk$set(out.width='800px', dpi=200, fig.align = "left")
#create basic graphs of tpf applications per year and country
load("data/TPF/tpf_families.RData")
getwd()
load("./data/TPF/tpf_families.RData")
#knitr::opts_chunk$set(out.width='800px', dpi=200, fig.align = "left")
#create basic graphs of tpf applications per year and country
getwd()
load("./data/TPF/tpf_families.RData")
load("../data/TPF/tpf_families.RData")
load("../../data/TPF/tpf_families.RData")
rm(list = ls())
blogdown:::serve_site()
#knitr::opts_chunk$set(out.width='800px', dpi=200, fig.align = "left")
#create basic graphs of tpf applications per year and country
load("../../data/TPF/tpf_families.RData")
#initialize the dataframe that holds all yearly counts of applicant countries
countries <- unique(c(levels(tpf_families$country_app), levels(tpf_families$country_inv))) #unique countries from both applicant and inventor data
ann_counts <- data.frame(matrix(nrow = (2017 - 1970) * length(countries), ncol = 4))
colnames(ann_counts) <- c("year", "country", "count_app", "count_inv")
ann_counts$year <- rep_len(1971:2017, length.out = length(ann_counts$year))
ann_counts$country <- rep(countries, each = 2017 - 1970)
#fill dataframe with counts. yearwhich and countrywhich_app/inv contain the positions of patent applications
#from the respective year or country(app and inv)
yearwhich <- sapply(1971:2017, FUN = function(x) {which(tpf_families$first_app_year == x)})
names(yearwhich) <- 1971:2017
countrywhich_app <- sapply(countries, FUN = function(x) {which(tpf_families$country_app == x)})
names(countrywhich_app) <- countries
countrywhich_inv <- sapply(countries, FUN = function(x) {which(tpf_families$country_inv == x)})
names(countrywhich_inv) <- countries
# the loop cycles through the country abbreviations and puts in counts by finding the intersections between year positions and countrypositions
for (i in unique(ann_counts$country)){
#print(i)
ann_counts[ann_counts$country == i, "count_app"] <- sapply(yearwhich, FUN = function(x) {length(intersect(x, countrywhich_app[i][[1]]))})
ann_counts[ann_counts$country == i, "count_inv"] <- sapply(yearwhich, FUN = function(x) {length(intersect(x, countrywhich_inv[i][[1]]))})
}
rm(countrywhich_app, countrywhich_inv, yearwhich, i, countries) #remove temporary variables
#make piechart using ggplot2
##graph total patent applications per year
#create the necessary dataset
annual_totals <- data.frame(matrix(nrow = 2017 - 1970, ncol = 2))
colnames(annual_totals) <- c("year", "applications")
annual_totals$year <- 1971:2017
annual_totals$applications <- sapply(1971:2017, FUN = function(x){sum(ann_counts[ann_counts$year == x, "count_app"])}) #count_app and count_inv yield equal application counts
#linegraph of TPF applications per year
library(ggplot2)
library(ggthemes)
install.packages("ggthemes")
blogdown:::serve_site()
#knitr::opts_chunk$set(out.width='800px', dpi=200, fig.align = "left")
#create basic graphs of tpf applications per year and country
load("../../data/TPF/tpf_families.RData")
#create basic graphs of tpf applications per year and country
load("../../patent data/TPF/tpf_families.RData")
blogdown:::serve_site()
##description
load("./patent data/TPF/201803_TPF_IPC.RData")
##description
load("./datasource/TPF/201803_TPF_IPC.RData")
blogdown:::serve_site()
load("./datasource/TPF/201803_TPF_Applicants.RData")
str(tpf_applicants)
#make a subset of tpf_applicants that only includes rows in which Country != "" & is not NA. In hope to speed up the loop
tpf_app.hascountry <- tpf_applicants[tpf_applicants$Country != "" & is.na(tpf_applicants$Country) == FALSE, c(1, 4)]
str(tpf_app.hascountry)
View(tpf_app.hascountry)
head(tpf_app.hascountry)
##initialize the list of country vectors (mutli-entry)
allcountries_app <- as.list(matrix(data = list(), nrow = max(tpf_applicants$Family_id), ncol = 1))
View(allcountries_app)
View(tpf_app.hascountry)
?lapply
start.time <- Sys.time() #measure computation time
for (i in 1:length(tpf_app.hascountry$Family_id)) {
y <- tpf_app.hascountry$Family_id[i]
allcountries_app[[y]] <- c(allcountries_app[[y]], tpf_app.hascountry$Country[i])
#cat(i)  #for monitoring progress
}
print(time.taken <- Sys.time() - start.time)
View(allcountries_app)
head(allcountries_app)
View(allcountries_app)
##initialize the list of country vectors (mutli-entry)
allcountries_app <- as.list(matrix(data = list(), nrow = max(tpf_applicants$Family_id), ncol = 1))
start.time <- Sys.time() #measure computation time
for (i in 1:length(tpf_app.hascountry$Family_id)) {
y <- tpf_app.hascountry$Family_id[i]
allcountries_app[[y]] <- c(allcountries_app[[y]], as.character(tpf_app.hascountry$Country[i]))
#cat(i)  #for monitoring progress
}
print(time.taken <- Sys.time() - start.time)
start.time <- Sys.time() #measure computation time
for (i in levels(tpf_app.hascountry$Country)) {     #cycle through all country factor levels
countrypos <- tpf_app.hascountry[tpf_app.hascountry$Country == i, "Family_id"] #find family ids associated with the country
for (y in countrypos) { #cycle through family ids found
allcountries_app[[y]] <- c(allcountries_app[[y]], i) #add respective country to the vector associated to family id
}
#print(i)  #for monitoring progress
}
print(time.taken <- Sys.time() - start.time)
View(allcountries_app)
start.time <- Sys.time() #measure computation time
for (i in levels(tpf_app.hascountry$Country)) {     #cycle through all country factor levels
countrypos <- tpf_app.hascountry[tpf_app.hascountry$Country == i, "Family_id"] #find family ids associated with the country
for (y in countrypos) { #cycle through family ids found
allcountries_app[[y]] <- c(allcountries_app[[y]], i) #add respective country to the vector associated to family id
}
cat(i)  #for monitoring progress
}
print(time.taken <- Sys.time() - start.time)
?cat()
start.time <- Sys.time() #measure computation time
for (i in levels(tpf_app.hascountry$Country)) {     #cycle through all country factor levels
countrypos <- tpf_app.hascountry[tpf_app.hascountry$Country == i, "Family_id"] #find family ids associated with the country
for (y in countrypos) { #cycle through family ids found
allcountries_app[[y]] <- c(allcountries_app[[y]], i) #add respective country to the vector associated to family id
}
cat(i, sep = " ")  #for monitoring progress
}
print(time.taken <- Sys.time() - start.time)
start.time <- Sys.time() #measure computation time
for (i in levels(tpf_app.hascountry$Country)) {     #cycle through all country factor levels
countrypos <- tpf_app.hascountry[tpf_app.hascountry$Country == i, "Family_id"] #find family ids associated with the country
for (y in countrypos) { #cycle through family ids found
allcountries_app[[y]] <- c(allcountries_app[[y]], i) #add respective country to the vector associated to family id
}
cat(i, " ")  #for monitoring progress
}
print(time.taken <- Sys.time() - start.time)
countrypos <- tpf_app.hascountry[tpf_app.hascountry$Country == "FR", "Family_id"]
countrypos
allcountries_app[[1]]
allcountries_app[[c(1, 2)]]
allcountries_app[c(1, 2)]
allcountries_app[c(1, 2)]
allcountries_app[c(1, 2)] <- c(allcountries_app[c(1, 2)], "hu")
allcountries_app[c(1, 2)] <- lapply(allcountries_app[c(1, 2)], FUN = function(x) c(x, "hu"))
allcountries_app
allcountries_app[c(1, 2)]
start.time <- Sys.time() #measure computation time
for (i in levels(tpf_app.hascountry$Country)) {     #cycle through all country factor levels
countrypos <- tpf_app.hascountry[tpf_app.hascountry$Country == i, "Family_id"] #find family ids associated with the country
# for (y in countrypos) { #cycle through family ids found
#   allcountries_app[[y]] <- c(allcountries_app[[y]], i) #add respective country to the vector associated to family id
# }
allcountries_app[countrypos] <- lapply(allcountries_app[countrypos], FUN = function(x) c(x, i))
cat(i, " ")  #for monitoring progress
}
print(time.taken <- Sys.time() - start.time)
start.time <- Sys.time() #measure computation time
for (i in levels(tpf_app.hascountry$Country)) {     #cycle through all country factor levels
countrypos <- tpf_app.hascountry[tpf_app.hascountry$Country == i, "Family_id"] #find family ids associated with the country
# for (y in countrypos) { #cycle through family ids found
#   allcountries_app[[y]] <- c(allcountries_app[[y]], i) #add respective country to the vector associated to family id
# }
allcountries_app[countrypos] <- sapply(allcountries_app[countrypos], FUN = function(x) c(x, i))
cat(i, " ")  #for monitoring progress
}
print(time.taken <- Sys.time() - start.time)
warnings()
start.time <- Sys.time() #measure computation time
for (i in levels(tpf_app.hascountry$Country)) {     #cycle through all country factor levels
countrypos <- tpf_app.hascountry[tpf_app.hascountry$Country == i, "Family_id"] #find family ids associated with the country
for (y in countrypos) { #cycle through family ids found
allcountries_app[[y]] <- c(allcountries_app[[y]], i) #add respective country to the vector associated to family id
}
cat(i, " ")  #for monitoring progress
}
print(time.taken <- Sys.time() - start.time)
start.time <- Sys.time() #measure computation time
for (i in levels(tpf_app.hascountry$Country)) {     #cycle through all country factor levels
countrypos <- tpf_app.hascountry[tpf_app.hascountry$Country == i, "Family_id"] #find family ids associated with the country
for (y in countrypos) { #cycle through family ids found
allcountries_app[y] <- c(allcountries_app[y], i) #add respective country to the vector associated to family id
}
cat(i, " ")  #for monitoring progress
}
?apply
allcountries_app[c(1, 2)] <-
apply(allcountries_app[c(1, 2)], 1, FUN = function(x) print(x))
allcountries_app[c(1, 2)] <-
apply(allcountries_app[c(1, 2)], 2, FUN = function(x) print(x))
sapply()
?sapply
start.time <- Sys.time() #measure computation time
for (i in levels(tpf_app.hascountry$Country)) {     #cycle through all country factor levels
countrypos <- tpf_app.hascountry[tpf_app.hascountry$Country == i, "Family_id"] #find family ids associated with the country
allcountries_app[countrypos] <- sapply(allcountries_app[countrypos], c, i)
cat(i, " ")  #for monitoring progress
}
print(time.taken <- Sys.time() - start.time)
unicountries_app <- as.list(matrix(data = list(), nrow = max(tpf_applicants$Family_id), ncol = 1))
####
start.time <- Sys.time()
for (i in levels(tpf_app.hascountry$Country)) {
countrypos <- tpf_app.hascountry[tpf_app.hascountry$Country == i, "Family_id"]
unicountries_app[countrypos] <- sapply(unicountries_app[countrypos], c, i)
cat(i, " ")
}
print(time.taken <- Sys.time() - start.time)
warnings()
View(unicountries_app)
unicountries_app <- as.list(matrix(data = list(), nrow = max(tpf_applicants$Family_id), ncol = 1))
start.time <- Sys.time()
unicountries_app <- lapply(allcountries_app, unique)
print(time.taken <- Sys.time() - start.time)
View(unicountries_app)
start.time <- Sys.time()
unicountries_app <- sapply(allcountries_app, unique)
print(time.taken <- Sys.time() - start.time)
rm(list = ls())
##This script creates and saves matrices containing single- and multi-entry (for international
##cases) vectors of the countries involved in filing patents, using both applicant and inventor data
load("./datasource/TPF/201803_TPF_Applicants.RData")
str(tpf_applicants)
#make a subset of tpf_applicants that only includes rows in which Country != "" & is not NA. In hope to speed up the loop
tpf_app.hascountry <- tpf_applicants[tpf_applicants$Country != "" & is.na(tpf_applicants$Country) == FALSE, c(1, 4)]
str(tpf_app.hascountry)
head(tpf_app.hascountry)
##initialize the list of country vectors (multi-entry)
allcountries_app <- as.list(matrix(data = list(), nrow = max(tpf_applicants$Family_id), ncol = 1))
### nested loop to create country vectors
start.time <- Sys.time() #measure computation time
for (i in levels(tpf_app.hascountry$Country)) {     #cycle through all country factor levels
countrypos <- tpf_app.hascountry[tpf_app.hascountry$Country == i, "Family_id"] #find family ids associated with the country
for (y in countrypos) { #cycle through family ids found
allcountries_app[[y]] <- c(allcountries_app[[y]], i) #add respective country to the vector associated to family id
}
cat(i, " ")  #for monitoring progress
}
print(time.taken <- Sys.time() - start.time)
head(allcountries_app)
save(allcountries_app, file = "./datasource/TPF/allcountries_app.RData")
rm(allcountries_app)
########create similar list that contains only unique country entries per list item
unicountries_app <- as.list(matrix(data = list(), nrow = max(tpf_applicants$Family_id), ncol = 1))
start.time <- Sys.time()
unicountries_app <- lapply(allcountries_app, unique)
print(time.taken <- Sys.time() - start.time)
head(unicountries_app)
save(unicountries_app, file = "./datasource/TPF/unicountries_app.RData")
rm(unicountries_app, tpf_app.hascountry, tpf_applicants)
##########do the same for the inventors dataset
load("./datasource/TPF/201803_TPF_Inventors.RData")
str(tpf_inventors)
#make a subset of tpf_applicants that only includes rows in which Country != "" & is not NA. In hope to speed up the loop
tpf_inv.hascountry <- tpf_inventors[tpf_inventors$Country != "" & is.na(tpf_inventors$Country) == FALSE, c(1, 4)]
str(tpf_inv.hascountry)
head(tpf_inv.hascountry)
##initialize the list of country vectors (mutli-entry)
allcountries_inv <- as.list(matrix(data = list(), nrow = max(tpf_inventors$Family_id), ncol = 1))
### nested loop to create country vectors
start.time <- Sys.time() #measure computation time
for (i in levels(tpf_inv.hascountry$Country)) {     #cycle through all country factor levels
countrypos <- tpf_inv.hascountry[tpf_inv.hascountry$Country == i, "Family_id"] #find family ids associated with the country
for (y in countrypos) { #cycle through family ids found
allcountries_inv[[y]] <- c(allcountries_inv[[y]], i) #add respective country to the vector associated to family id
}
cat(i, " ")  #for monitoring progress
}
print(time.taken <- Sys.time() - start.time)
head(allcountries_inv)
save(allcountries_inv, file = "./datasource/TPF/allcountries_inv.RData")
rm(allcountries_inv)
########same procedure for unique countries
unicountries_inv <- as.list(matrix(data = list(), nrow = max(tpf_inventors$Family_id), ncol = 1))
start.time <- Sys.time()
unicountries_inv <- lapply(allcountries_inv, unique)
print(time.taken <- Sys.time() - start.time)
head(unicountries_inv)
save(unicountries_inv, file = "./datasource/TPF/unicountries_inv.RData")
rm(unicountries_inv)
rm(list = ls())
##This script creates and saves matrices containing single- and multi-entry (for international
##cases) vectors of the countries involved in filing patents, using both applicant and inventor data
load("./datasource/TPF/201803_TPF_Applicants.RData")
str(tpf_applicants)
#make a subset of tpf_applicants that only includes rows in which Country != "" & is not NA. In hope to speed up the loop
tpf_app.hascountry <- tpf_applicants[tpf_applicants$Country != "" & is.na(tpf_applicants$Country) == FALSE, c(1, 4)]
str(tpf_app.hascountry)
head(tpf_app.hascountry)
##initialize the list of country vectors (multi-entry)
allcountries_app <- as.list(matrix(data = list(), nrow = max(tpf_applicants$Family_id), ncol = 1))
### nested loop to create country vectors
start.time <- Sys.time() #measure computation time
for (i in levels(tpf_app.hascountry$Country)) {     #cycle through all country factor levels
countrypos <- tpf_app.hascountry[tpf_app.hascountry$Country == i, "Family_id"] #find family ids associated with the country
for (y in countrypos) { #cycle through family ids found
allcountries_app[[y]] <- c(allcountries_app[[y]], i) #add respective country to the vector associated to family id
}
cat(i, " ")  #for monitoring progress
}
print(time.taken <- Sys.time() - start.time)
head(allcountries_app)
save(allcountries_app, file = "./datasource/TPF/allcountries_app.RData")
########create similar list that contains only unique country entries per list item
unicountries_app <- as.list(matrix(data = list(), nrow = max(tpf_applicants$Family_id), ncol = 1))
start.time <- Sys.time()
unicountries_app <- lapply(allcountries_app, unique)
print(time.taken <- Sys.time() - start.time)
head(unicountries_app)
save(unicountries_app, file = "./datasource/TPF/unicountries_app.RData")
rm(unicountries_app, allcountries_app, tpf_app.hascountry, tpf_applicants)
##########do the same for the inventors dataset
load("./datasource/TPF/201803_TPF_Inventors.RData")
str(tpf_inventors)
#make a subset of tpf_applicants that only includes rows in which Country != "" & is not NA. In hope to speed up the loop
tpf_inv.hascountry <- tpf_inventors[tpf_inventors$Country != "" & is.na(tpf_inventors$Country) == FALSE, c(1, 4)]
str(tpf_inv.hascountry)
head(tpf_inv.hascountry)
##initialize the list of country vectors (mutli-entry)
allcountries_inv <- as.list(matrix(data = list(), nrow = max(tpf_inventors$Family_id), ncol = 1))
### nested loop to create country vectors
start.time <- Sys.time() #measure computation time
for (i in levels(tpf_inv.hascountry$Country)) {     #cycle through all country factor levels
countrypos <- tpf_inv.hascountry[tpf_inv.hascountry$Country == i, "Family_id"] #find family ids associated with the country
for (y in countrypos) { #cycle through family ids found
allcountries_inv[[y]] <- c(allcountries_inv[[y]], i) #add respective country to the vector associated to family id
}
cat(i, " ")  #for monitoring progress
}
print(time.taken <- Sys.time() - start.time)
head(allcountries_inv)
save(allcountries_inv, file = "./datasource/TPF/allcountries_inv.RData")
########same procedure for unique countries
unicountries_inv <- as.list(matrix(data = list(), nrow = max(tpf_inventors$Family_id), ncol = 1))
start.time <- Sys.time()
unicountries_inv <- lapply(allcountries_inv, unique)
print(time.taken <- Sys.time() - start.time)
head(unicountries_inv)
save(unicountries_inv, file = "./datasource/TPF/unicountries_inv.RData")
rm(unicountries_inv, allcountries_inv, tpf_inv.hascountry, tpf_inventors)
rm(list = ls())
load("./datasource/TPF/201803_TPF_Core.RData")
tpf_families <- subset(tpf_core, select = c(Family_id, USPTO_app_first, EPO_app_first, JPO_app_first,
PCT_app_first))
rm(tpf_core)
View(tpf_families)
tpf_families[, 2:5] <- lapply(tpf_families[, 2:5], as.Date, format = "%Y%m%d")
#tranform application dates into date format
tpf_families[, 2:5] <- lapply(tpf_families[, 2:5], as.character)
tpf_families[, 2:5] <- lapply(tpf_families[, 2:5], as.Date, format = "%Y%m%d")
load("./datasource/TPF/201803_TPF_Core.RData")
tpf_families <- subset(tpf_core, select = c(Family_id, USPTO_app_first, EPO_app_first, JPO_app_first,
PCT_app_first))
#tranform application dates into date format
tpf_families[, 2:5] <- lapply(tpf_families[, 2:5], as.character)
View(tpf_families)
tpf_families <- subset(tpf_core, select = c(Family_id, USPTO_app_first, EPO_app_first, JPO_app_first,
PCT_app_first))
#tranform application dates into date format
#tpf_families[, 2:5] <- lapply(tpf_families[, 2:5], as.character)
tpf_families[, 2:5] <- lapply(tpf_families[, 2:5], FUN = function (x) {as.Date(as.character(x))}, format = "%Y%m%d")
#tranform application dates into date format
#tpf_families[, 2:5] <- lapply(tpf_families[, 2:5], as.character)
tpf_families[, 2:5] <- lapply(tpf_families[, 2:5], FUN = function (x) {as.Date(as.character(x), format = "%Y%m%d")})
View(tpf_families)
str(tpf_families)
tpf_families
load("./datasource/TPF/201803_TPF_Core.RData")
tpf_families <- subset(tpf_core, select = c(Family_id, USPTO_app_first, EPO_app_first, JPO_app_first,
PCT_app_first))
#tranform application dates into date format
tpf_families[, 2:5] <- lapply(tpf_families[, 2:5], as.character)
tpf_families[, 2:5] <- lapply(tpf_families[, 2:5], as.Date, format = "%Y%m%d")
View(tpf_families)
str(tpf_families)
tpf_families <- subset(tpf_core, select = c(Family_id, USPTO_app_first, EPO_app_first, JPO_app_first,
PCT_app_first))
tpf_families[, 2:5] <- lapply(tpf_families[, 2:5], FUN = function (x) {as.Date(as.character(x), format = "%Y%m%d")})
